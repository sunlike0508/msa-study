# msa-study


인프라가 가변적으로 쉽게 변경되는 클라우드 환경

이때 수평확장을 위한 가장 효율적인 시스템 유형

cloud native application == miroservice

# 모노리스와 마이크로서비스

## 모노리스 시스템

어플리케이션이 한 덩어리로 구성

단일 프로세스로 실행

한꺼번에 수정, 배포가 되어야 함

하나가 실패하면 모두 실패 됨을 의미

모노리스를 클라우드 인프라에서 활용 시에 스케일 아웃의 대상은 모노리스 전체가 된다.

그것만으로 충분히 확장성, 탄력성이 보장이 가능하나 비용 효율적이지 않음

## 마이크로서비스

어플리케이션이 여러개 서비스 조각으로 구성

각기 독립적인 기능 제공

서비스가 사용하는 저장소는 다른 서비스와 완벽히 격리

따라서 독립적 수정 가능, 별도 배포, 확장 가능

하나의 서비스 실패는 전체 실패가 아닌 부분적인 실패

여러 개의 작은 서비스 집합으로 개발하는 접근 방법

각 서비스는 개별 프로세스에서 실행

HTTP 자원 API(RESTFUL API) 수단 사용 통신

서비스는 Biz 기능 단위로 구성(중앙 집중적 관리 최소화)

각 서비스는 서로 다른 언어, 데이터, 저장 기술 사용 가능

*  Polyglot : 각자의 서비스에 잘 맞는 언어, db, 프레임워크등 사용할 수 있는 것

### 마이크로서비스 성공 조건

클라우드 적용시 가장 이상적인 어플리케이션 유형은 마이크로서비스.

이는 기술 아키텍처 변화에 국한되지 않은 개발 프로세스, 조직, 개발 문화 등의 변화가 필요함.

* 조직 : 특정 도메인에 자율적인 권한과 책임을 지는 DevOps 조직

* 인프라 : 언제나 쉽게 확장 가능한 유연한 인프라 구성
  * 유연하고 민첩하게 제공되는 가변적인 인프라
  * public, private hybrid Cloud 설정
  * Infra as Code
  * Immutable Infra 배포된 후 변경되지 않는 인프라 패러다임

* 자동화 : 개발지원 도구 자동화, DevOps Infra(CI/CD)
   * 개발 지원용 자동화 도구 필요
   * 개발 지원 도구
   * 형상관리, 빌드/테스트/배포 자동화 CI/CD
   
* 개발 프로세스 : 피드백 기반의 개발 프로세스, 반복/점진적인 애자일 프로세스

* 개발 문화 : 공유/협업하고 학습하여 계속 진화하는 개발 문화(공유, 협업, 책임, 학습)

* 설계 방식 : 데이터 중복, 결과적 일관성 추구

테스트서버, 운영서버 배포했을 때 똑같이 돌아가도록 환경을 구성해야한다.

빌드 -> 패키징 -> 구성 -> 테스트 -> 배포

이 과정을 파이프라인으로 구성해서 개발, 운영 똑같이 만든다.

요즘 시대는 예전처럼 장기간 프로젝트를 통해 개발 X

2~3주의 Iteration 또는 스프린트(스크럼이라는 애자일에서 나온 용어)를 통한 개발 -> 피드백


**마이크로서비스 아키텍처 적용한다고 우리 회사가 넷플릭스고 아마존인가? 아니다. 개발문화, 프로세스 등 조직 전반에 걸쳐 바꿔야 한다.**

기존에는 개발과 운영이 따로 생각. 그러나 이제는 개발과 운영이 같이 가야한다. 벽이 없다.

기획자 + 디자이너 + 설계자 + 개발자 + 테스터 = 신속한 개발

속도, 책임감, 문제 발생시 쉬운 개선 => 완벽한 DevOps 조직

* 콘웨이 법칙 : 다 기능 팀 내부의 응집력 높이기

다기능 간의 의존성은 낮게

그럼 이런 다 기능을 가진 조직을 만들어야 하냐?

하면 좋다만 안된다면 그 간격(개발과 운영)을 줄이기 위한 노력을 해라.

#### 전체적인 상세 조건

피드백이 가시화, 작업간격 축소.

지속적인 피드백, 빠른 문제 감지 및 복구

(자동화 테스트, 피어 리뷰)

생산적인 신뢰 / 협업 문화 생성

(실험, 비난하지 않는 포스트 모텀(post-mortems, 지속적인 학습, 내부 기술 컨퍼런스)

결국은 신속 / 정확 / 협업 등이 잘 이루어진 조직을 먼저 만들어야 마이크로서비스가 잘 된다.

#### 장애처리

장애가 난다.

개인이 문제인가?

개인의 문제가 아닌 조직의 문제 관점으로 보자.

개인이 만든 개발 코드를 배포전까지 자동화 프로세스가 없던거 아닐까?

장애들의 대해서 문제를 서로 얘기하고 학습하고 공유하는 문화

#### Polyglot Persistence 접근 방법 사용

서비스 별 데이터베이스 설계 (각 저장소 분산 필수, 다른 서비스 저장소 호출 불가능, API만 통하여 접근 가능)

데이터 중복, 결과적 일관성 -> 이게 중요.

마이크로서비스로 설계하면 데이터 일관성 문제가 발생

언제든지 실패할 수 있음.

실패해서 더 이상 진행할 수 없을 때도 자연스럽게 대응할 수 있도록 설계.

자동으로 테스트할 수 있는 환경 설정

실패 감지 및 대응을 위한 실시간 모니터링 체계 필요

#### 서킷 브레이크 패턴

서비스 모니터링 서비스 다운 또는 실패 시 호출하는 서비스의 연계 차단, 적절한 대응을 위해 만듦.


#### 결론

성공적인 마이크로서비스를 만들기 위해서 3가지.

1) 유연하고 자동화된 개발환경

2) 점진, 반복적인 개발 프로세스

3) 자율적인 업무 기능 팀과 개발 문화


# 마이크로서비스 성숙도

No silver Bullet

만병통치약은 없다.

마이크로서비스는 MSA의 구성요소 중 하나임.

 
## 오해

* 컨테이너, 쿠버네티스 사용하면 MSA를 하는 것이라고 생각

* 클라우드 인프라 위에 무조건 마이크로서비스 올라가야 함

* 마이크로서비스로 구축하면 시스템 유연해지고 확장성 높아지고 비즈니스도 민첩해질 것이다.

* 대기업이 되기 위해서는 마이크로서비스가 필수다.

위에 모두 오해이다. 아키텍처는 정답이 없다.

아키텍처는 각기 다른 상황에 따른 최선의 선택이고 trade-off 해야한다.

## MSA 아키텍처 발전과정

<img width="1069" alt="image" src="https://github.com/user-attachments/assets/8230e7c9-0318-4d69-a6ac-f632abd1c08c">

좌측에서 우측으로 갈 수록 점진적인 진화형태

많은 시간과 비용이 듦. 대신 리스크가 커짐

당연히 오른쪽으로 갈수록 확장성, 배포성, 탄력성 확보

성능은 오른쪽으로 갈수록 떨어짐. 왜냐하면 결국 인스턴스가 따로 만들어지기 때문에 네트워크 문제가 발생(반응 시간 : latency)

마이크로서비스의 경우 고도의 디커플링을 요구

재사용은 커플링을 유발하기 때문에 재사용보다 중복을 우선시 함. (각 인스턴스가 같은 데이터를 가지고 있는 것)

잦은 네트워크 호출이 필요하므로 성능은 다소 부정적이며 보안처리, 분산 트랜잭션 등 난이도와 복잡도가 높아짐.

저장소의 완벽한 격리 필요하며, 통합 데이터 모델링 사상과 상충되며 데이터 중복, 복제가 고려되어야 함.

따라서 데이터 일관성 처리를 위한 결과적 일관성 매커니즘 필요(복잡도 증가)

## 아키텍처 개념 과 레이어드 아키텍처

아키텍처를 큰 구조, 청사진, 패턴 이렇게 부르는 거임.

아키텍처를 결정하는 여러가지 조건을 따져보고 맞게 선택

특성 : 가용성, 신뢰성, 시험성, 확장성, 보안, 민첩성, 탄력성, 성능, 배포성, 학습성

결정 : 시스템의 제약조건, 개발자가 해도 되는것, 안되는것 정의

설계원칙 : 아키텍처 결정을 만족시키는 가이드 라인

시스템 구조 : 아키텍처 결정 및 설계 원칙에 적합한 상위 수준의 시스템 구조를 정의


비즈니스 요건을 분석 -> 그에 맞는 아키텍처 특성 도출

정의된 아키텍처에 기반한 컴포넌트 모듈화, 식별하고 적절한 역할 및 책임을 부여함.

도메인 기능이 응집되도록 컴포넌트를 도출하고 컴포넌트 간 의존관계를 줄이도록 함.

## 아키텍처 종류

레이어드

파이프라인

마이크로커널

서비스 기반 (이게 soa)

이벤트 기반

공간 기반

오케스트레이션 기반

마이크로서비스

* 책추천 : Fundamentals of Software Architecture 마크 리처드, 닐포드, 한빛 미디어


## 레이어드 아키텍처

엔터프라이즈에서는 사실상 표준 아키텍처

### 특징

관심사의 분리

기술 분할

아키텍처 결정사항 : 레이어 개방/폐쇄 여부

이키텍처 싱크홀 안티 패턴 (바로 아래 레이어가 아닌 두,세 단계 아래 레이어 바로 접근할수 있게 정의 할수 있음, 성능이나 여러 이유로 인해서)

단순, 소규모, 비용작음

의존성의 역전(요청 역전)으로 구성할수도 있음

대표적 구현된 아키텍처 : OSI 7계층

 
### MVC 패턴의 오해

MVC는 프레젼테이션 레이어를 구현한 하나의 패턴일뿐

이게 전체 어플리케이션을 구성하는 아키텍처는 아니다.

프레젠테이션 레이어가 controller이고 결과가 나온 값을 주는게 model이고 이걸 보여주는 view


## 파이프라인 아키텍처

파이프와 필터

Bash, Zsh 등 유닉스 터미널 쉘 언어의 기초 원리

### 필터의 종류

1)프로듀서, 프로세스 시적점, 소스

2)변환기, 입력을 받아 일부 또는 전체를 변환한 후 전달, map

3)테스터: 기준에 따라 테스트, 결과 생선, reduce

4)컨슈머: 흐름 종착역, 데이터베이스 저장, 화면출력

단방향 단순, 조합 가능

EDI(전자데이터 교환), ETL(추출, 변환, 적재)

필터 -> 필터 -> 필터 -> 필터

이때 필터 사이에 파이프를 두는 것

배치에서 자주 사용


## 마이크로 커널 아키텍처

플러그인 아키텍처라고 보면 됌

이클립스 IDE, 지라, 젠킨스, 크롬 같이

내가 원하는 마켓에서 플러그인 설치해서 내가 원하는 코어 시스템 추가 확장 변경 하는 것.

단순하고 비용이 적음.

자동차 옵션이라고 보면됌
 
## 서비스 기반 아키텍처

MSA는 서비스 기반 아키텍처 중에 하나이다.

유연성 있는 대규모 분산 레이어 구조

도메인 서비스 보통 4 ~12개, 평균 7개

REST, RPC, SOAP

중앙 공유 데이터베이스 사용(조인 기능 사용)

신뢰성, 내고장성

그럼 MSA랑 다른건?

구조가 크다.

데이터베이스가 하나이다.

### 여러 형태의 변형

1. 유저 인터페이스 변경

   1) 하나의 유저인터페이스
   
   2) 2개 이상의 유저인터페이스, 3개 이상의 서비스
   
   3) 각 서비스별 유저인터페이스

서비스, 유저인터페이스를 쪼갤수록 변경하기 쉬움

마이크로 프론트앤드(ex: 아마존).

대신 성능은 조금 떨어질수 있음

<img width="749" alt="image" src="https://github.com/user-attachments/assets/6fe2da35-1db5-4f63-b401-d0da4116d05d">


2. 데이터 베이스 변경

개별 데이터베이스로 분리(마이크로서비스랑 유사)

각 데이터베이스에 있는 도메인 데이터를 다른 도메인의 서비스가 필요하지 않도록 설계하는 것이 중요.

통합db, 도메인별db, 조회용db, 서비스별db 격리

읽기용 서비스 db, 쓰기용 서비스 db (이게 CQRS)

이때 쓰기용 db랑 조회용 db랑 일관성을 맞춰야함.

어떻게 맞출꺼냐?

CUD가 일어날때마다 읽기 db에 넘겨주기 (이때 살짝 딜레이를 줌, entual consistency)

<img width="969" alt="image" src="https://github.com/user-attachments/assets/014df2f2-9c4b-4c52-8e6f-f3b29434fe1a">


3. 서비스 내부 설계

서비스 안에는 레이어드 설계 vs 도메인 설계(도메인 분할)

세분도가 크기 때문에 API 퍼사드 통한 내부 클래스 수준의 오케스트레이션 필요

<img width="1033" alt="image" src="https://github.com/user-attachments/assets/4f9be9cb-ecce-43b0-b69f-098d33feea70">

4. 서비스 내부 설계

서비스 안에는 레이어드 설계 vs 도메인 설계(도메인 분할)

세분도가 크기 때문에 API 퍼사드 통한 내부 클래스 수준의 오케스트레이션 필요

<img width="1019" alt="image" src="https://github.com/user-attachments/assets/534db24e-2159-420d-a246-24579e748a94">


* 정리 

일반적으로 모놀리식 데이터베이스 공유

데이터베이스 커플링 문제, 스키마 변경 시 변경 영향도 문제 발생

이를 낮추기 위해 논리적으로 분할, 전용 공유 라이브러리화, 도메인별 접근권한 분리

<img width="1012" alt="image" src="https://github.com/user-attachments/assets/905eca62-d635-4d3b-899e-729d7ed4ffcd">


## 이벤트기반 아키텍처

확장성이 뛰어난 고성능 어플리케이션 개발에 쓰이는

비동기 분산 아키텍처.

다른 아키텍처에 내장 가능(ex: 이벤트 기반 마이크로서비스 아키텍처)

브로커 토폴로지

이벤트(사건)에 액션이 반응하는 방식 진행

RabbitMQ, ActiveMQ등 경량 메시지 브로커

### 스타일은 두가지가 있음
 
1) 코레오그래피(choreography): 각자 자율적 이벤트 처리

장점 : 확장성, 응답성, 성능(이건 좀 상대적)

단점 : 트랜잭션 통제 힘듬, 교착상태, 데이터비일관성, 에러처리 어려움

<img width="680" alt="image" src="https://github.com/user-attachments/assets/3c0021eb-b2a0-4e8f-a78d-02605e2cf4d3">

2) 오케스트레이션

이벤트는 사건이 아니라 커멘드(일어나야할일)

장점 : 에러처리

단점 : 확장성, 중재자가 병목지점, 커플링으로 성능저하

<img width="859" alt="image" src="https://github.com/user-attachments/assets/db2733d0-bee8-4f47-a89d-12e5e9db2967">

## 공간 기반 아키텍처 스타일

높은 확장성, 탄력성, 동시성

동시 유저수가 매우 가변적이라 예측조차 곤란한 애플리케이션에 유용

복제된 인 메모리 그리드

데이터펌프, 데이터라이터, 데이터리더

<img width="973" alt="image" src="https://github.com/user-attachments/assets/b5a911ae-b3c0-42f3-87b9-373d74d0136d">


## 오케스트레이션 기반 서비스 지향 아키텍처 스타일

제약이 많은 분산 아키텍처

벤더 중심, 기술분할에 집착

비즈니스 행위 재사용 강조

오케스트레이션 엔진

재사용으로 인한 서비스 간 의존성 높아짐

사실상 실패 아키텍처

<img width="763" alt="image" src="https://github.com/user-attachments/assets/a1413059-136f-491e-b55f-fb5c45b823f1">


## 마이크로 서비스 기반 아키텍처 스타일

분산 아키텍처, 성능은 그닥, 세분도가 중요.

데이터 격리, 재사용보다 중복, 프로토콜 인지 이종간 상호 운용성

API 레이어(API gateway), 고도의 디커플링 추구

API 레이어는 가볍게, 비즈니스 로직이 X

<img width="854" alt="image" src="https://github.com/user-attachments/assets/b26f5f39-23fd-4419-b682-f34dde86fa92">

### 정리

아키텍처를 결정하기 전에 비즈니스의 요구사항을 잘 알아야함.

ex) 데이터의 즉시 일관성이 필요? 그럼 이벤트 기반 아키텍처는 힘듬.

도메인, 데이터 아키텍처, 조직역량, 개발 프로세스등

애자일 프로세스 역량이 없는데 최신기술? ㄴㄴ

소프트웨어 아키텍처의 모든 것은 트레이드 오프

어떻게 보다 '왜'가 더 중요하다.


# 마이크로서비스 아키텍처 구성요소

## MSA 패턴 유형

MSA는 여러 개의 서비스간의 연계를 통해 시스템을 구축하는 SOA의 범주에 있다.

SOA(service-oriented architecture)는 서비스 인터페이스를 통해 소프트웨어 구성 요소의 재사용과 상호 운용성을 가능하게 하는 방법을 정의합니다. 

서비스는 공통 인터페이스 표준과 아키텍처 패턴을 사용하므로 새로운 애플리케이션에 신속하게 통합될 수 있습니다. 

이로써 애플리케이션 개발자는 기존의 기능을 재개발 또는 복제하거나 기존의 기능을 연결하거나 상호 운용성을 제공하는 방법을 알아야 했던 수고를 덜 수 있습니다.

* innner architecture : 개발자가 흔히 개발하는 인스턴스 안에 들어가는 비즈니스 아키텍처

* outer architecture : 서비스(인스턴스)가 효과적인 운영 관리 지원을 위한 것

<img width="683" alt="image" src="https://github.com/user-attachments/assets/47ea2087-0689-4ec5-9a42-9fceb56bff13">

## MSA 패턴

<img width="1076" alt="image" src="https://github.com/user-attachments/assets/65887ef2-7994-4bb7-a35d-773bc857f40d">

***MSA를 돕든 제품들이 왜 필요한가? 이렇게 접근해야함.***

그 전에도 말했듯이 최신? 잘 쓰니까? 이게 아니라 왜 쓰는가?

MSA의 패턴을 이해하는 것이 중요


## MSA 구성요소

<img width="1030" alt="image" src="https://github.com/user-attachments/assets/5976018e-2207-46fa-8da7-1cf10062e0e7">

## 구조화

<img width="1081" alt="image" src="https://github.com/user-attachments/assets/8b7edd9b-a1a4-4055-b0a0-8c6af2a4f724">


### 인프라와 플랫폼에 관련된 패턴 이해

코드 개발

코드 저장(repo) : git

// 여기까지 CI

build automation (image store에 저장(도커)

deploy automation(도커의 이미지를 환경설정(config store)에 따라서 배포)

container management platform(ex : 쿠버네티스, vm, 오케스트레이션 컨테이너)이 배포된 이미지를 backing service에 맞게 운영

// 여기까지 CD

라우터 : 웹, 모바일 등 클라이언트가 서비스를 찾아 가기 위해 찾아주는 것

서비스 디스커버리 : 컨테이너 IP와 서비스 이름 찾는것. DNS같은

로드 밸런싱 : 어떤 컨테이너로 보낼것인가

인증/인가

모니터링 : 로그

diagnostics : 추적, tracing, 서킷브레이크

# 인프라

## 인프라 패턴

build automation : CI(지속적 통합), 도커, 젠킨스, 깃헙

deploy auto : CD(지속적 배포), AWS ECR, 도커허브, HARBOR

위에 제품들은 각 패턴유형의 대표 제품들

### 인프라에 관련된 패턴 이해

보통 클라우드 or DevOps 인프라 패턴

• 인프라플랫폼(IaaS) : AWS EC, Azure VMs , OpenStack
• 컨테이너플랫폼(CaaS): AWS ECS,EKS,AKS,GKE , k8s, DC/OS, Docker Datacenter
• 어플리케이션플랫폼(PaaS,aPaaS): Heroku,PCF,CloudFondy,OpenShift
• 함수플랫폼(FaaS) : Lambda,Azure Functions,GCF, OpenWhik
• 소프트웨어플랫폼(SaaS): Saleforce,Oracle,SAP,OpenFaaS,fission,Knative

<img width="1091" alt="image" src="https://github.com/user-attachments/assets/63da561f-c202-4181-9ba6-59399a6c5a1c">

구글 docs처럼 구글의 대표적인 제품들이 SaaS의 예시


## VM vs 컨테이너

### vm (가상 머신)

게스트 OS 관리 오버헤드, virtualbox, vmware

가상머신의 하이퍼바이저 위에 각 vm이 있고 vm은 각 게스트 os를 가지고 있는데 이때 게스트 os가 커널.

커널의 단점은 많은 라이브러리를 가지고 있어서 무겁다.

그래서 배포, 부팅 속도가 느림.

### 컨테이너

컨테이너 런타임 : OpenVZ, Docker가 사실상 표준

개발과 배포가 편해짐, 독립된 개발 환경 보장

개발/운영 환경의 통합 : 개발 환경 그대로 다른 서버에 똑같이 복제 가능

커널을 포함하지 않으므로 이미지가 크지 않고, 배포속도가 빠름

애플리케이션의 독립성과 확장성이 높아짐 : 마이크로 서비스

Stateless, 불변성

컨테이너는 하이퍼바이저가 아닌 컨테이너 런타임이 있는데 vm의 게스트 os(커널)를 공통으로 가지고(공유) 있기 때문에 빠르다.

애플리케이션 구동을 위한 라이브러리 & 실행파일을 가지고 있음.

<img width="1153" alt="image" src="https://github.com/user-attachments/assets/b4a6575a-3184-4464-8d66-adaf669752e5">

## 도커

도커엔진

도커이미지 : 컨테이너 생성시 필요한 요소, 여러개의 계층으로 된 바이너리 파일, 읽기 전용

이미지 저장소

도커컨테이너 : 도커이미지로 생성, 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간 생성

기본명령어

• Docker run –I –t ubuntu:14.04
 
실행 동작

이미지를 도커허브에 넣어놓고 우분투가 도커허브에 이미지를 가져와서 도커(컨테이너)에 실행

#### 수동작업

<img width="1060" alt="image" src="https://github.com/user-attachments/assets/b169034d-ba6c-428c-9c47-11146d6d4595">

#### 자동

Dockerfile로 이미지 생성 자동화

• 빌드 명령어 제공, 컨테이너에 설치해야 할 패키지,추가해야 할 소스코드 ,실행해야 할 명령어,쉘 스크립트등을 하나의 파일에
기록 , 도커엔진이 읽어들어 이미지 생성
• 쉽게 배포 가능

<img width="890" alt="image" src="https://github.com/user-attachments/assets/265b30e8-7083-4474-9c0c-ef4a05168b73">

### 컨테이너 라이브 사이클

도커파일로 빌드하면 이미지가 생기고 이거를 도커허브에 저장.

나중에 컨테이너를 생성하면 도커허브에 이미지를 가져와 commit 실행.

<img width="1096" alt="image" src="https://github.com/user-attachments/assets/c33aab9b-5eed-44eb-a4d7-01438c8ce52c">

### 도커 컨테이너

빌드 컨텍스트 : 이미지를 생성하는데 필요한 각종 파일, 소스코드, 메타 데이터를 담고 있는 디렉토리

기반이미지 위에 레이어, 그 위에 레이어, 그 위에 레이어 계속 쌓아감.

절차적이 아닌 선언적 방식으로 되어 있다.

어떻게 할것이 아닌 무엇을 할것인가?

### 컨테이너 오케스트레이션

하나의 호스트 머신에서 도커엔진으로 구동하다가 cpu, 메모리, 디스크용량과 같은 자원이 부족하면 어떻게 할것인가?

-> 서버 클러스팅으로 자원을 병렬로 확장

새로운 서버, 컨테이너가 추가 됐을 때 discovery 하는 일

스케쥴링 : 어떤 서버에 컨테이너를 할당할 것인가

부하분산(로드밸런서)

장애복구 : 서버가 다운되었을 때, 고 가용성 보장

#### 해결

위에 것들을 해결하기 위해 나온 제품이 바로 k8s(쿠버네티스), MESOS, Docker Swarm

컨테이너 배포, 스케일링, 로드밸런싱, 네트워킹 자동화

애플리케이션 레벨의 서비스를 제공하지는 않음

(미들웨어, 데이터처리, 데이터 스토리지)

로깅, 모니터링, 경보는 포함 되지 않음

보통 매니저 노드가 있고 그 아래 여러 워커 노드를 포함하도록 구성되어 있음.

서비스 : 같은 이미지에서 생성된 컨테이너 집합, 생성된 컨테이너를 레플리카라 함.

매니저노드가 워커노드 2개를 가지고 있엇다.

그때 하나가 죽음 다른 워커노드 안에 2개의 컨테이너를 만듬.

이때 2개의 집합을 레플리카

replica = 2

컨테이너들을 관리, 즉 자동 스케쥴링, 자동 확장, 자동 배포등을 하는 것의 대표주자가 쿠버네티스

## 쿠버네티스

• Kubernetes àk8s
• Automatic bin packing
• Self-Healing
• Horizontal scaling
• Service discovery and Load balancing
• Automated rollouts and rollbacks
• Secret and Configuration management
• Storage orchestration
• 모든리소스는오브젝트형태로관리
• 명령어보다는YAML
• Pod, Replicaset, Service,
• Deployment, Configmap,secret,
• Ingress

<img width="818" alt="image" src="https://github.com/user-attachments/assets/fe04f7d7-f4a2-482d-9e63-875c5b5fc7f5">

service discovery : 한가한 워커노드의 컨테이너를 찾은 기능

무중단 배포 관리

<img width="1103" alt="image" src="https://github.com/user-attachments/assets/8900cc96-ffdc-4bf4-af82-963585fe4130">

애플리케이션이 올라가는 컨테이너를 만드는게 도커

이 도커를 관리 해주는 쿠버네티스

### Pod

Pod : 컨테이너를 다루는 기본단위

컨테이너 = pod

1개 이상의 컨테이너로 구성

하나의 완전한 애플리케이션으로 동작

Pod 안에 Ngix컨테이너(우리가 흔히 개발하는 것), 사이드카(인증/인가, 로깅 같은거) 이렇게 있음

그냥 pod는 하나의 컨테이너다라고 인식하고 가도 됌


### 레플리카셋(replicaset)

<img width="1305" alt="image" src="https://github.com/user-attachments/assets/8bf59043-5361-4064-9f98-155a633dcc7c">


정해진 수의 동일한 포드가 항상 실행되도록 관리

노드 장애 등의 이유로 포드가 사용할 수 없다면 다른 노드에서 포드 다시 생성

replica= 3로 선언했으니 pod를 3개 만듬

이런거를 보통 yaml으로 선언적 작성.

pod, replica 각각 선언할수있는데 이거를 한꺼번에 선언하는 것이 deployment

service(clusterIP) : 알아서 라우팅, 로드밸런싱 해줌.

ingress : 서비스를 OSI 계층에서 로드밸런싱 해주는것. url기반으로

### deployment

<img width="1248" alt="image" src="https://github.com/user-attachments/assets/733417b9-548b-4b35-a824-d97a9b9b6b73">


Pod set, ReplicaSet을 한번에 = deployment

업데이트 배포를 더욱 편하게 함.

애플리케이션 변경시 레플리카셋의 변경사항을 저장하는 리비전을 남겨 롤백 가능

무중단 서비스를 위해 롤링 업데이트 전략 지정 가능

### Service

포드를 연결하고 외부에 노출

여러 개의 포드에 쉽게 접근할 수 있도록 고유한 도메인 이를 부여,

여러 개의 포드에 접근 할때 요청을 분산하는 로드밸런서 수행

clusterIP(보통 이거 씀), NodePort(어플리케이션 포트랑 머신포트랑 연결하는것, 물리적 포트, 노드의 port를 열어 외부에서 접속하도록), LoadBalancer

4개의 레플리카를 설정하고 실행. (nodeport를 30080으로 설정)

이때 스케일 아웃후 로드밸런싱 잘되는 지

확인(kubectl get deployment)하면

랜덤으로 Pod에 붙는 것을(curl host01:30080)

확인할 수 있다.

후에 하나의 pod를 죽이면

(kubectl delete pod podName(pod이름))

알아서 신규Pod를 만든다.

yaml로 레플리카set를 설정할수있고

혹은 명령어로 가능

kubectl scale --replicas=5 deployment/webapp1

명령어가 쿠버네티스 마스터안에 있는 etcd라는 곳에 저장됌

그러시면 마스터안에 컨트롤러메니저가 etcd를 주시하고 있다가 자동으로 스케일링해줌.

### ingress

url 기반으로 로드밸런싱

ssl 보안 연결

인그레스 규칙

인그레스 컨트롤러 서버, Nginx 웹서버 인그레스 컨트롤러

### Configmap(설정값)

컨테이너는 수정할 필요가 없다(상태를 가질 필요가 없다). 즉, 불변성. 이미지로 관리하니까 개발이나 운영이나 같은 환경으로 사용.

이때 이미지는 개발이나 운영이나 똑같이 배포하는 것은 좋은데 db는 다르게 해야 하잖아.

이런 가변적인요소(db 저장소)들을 컨테이너 관리와 다르게 컨테이너에서 필요한 환경 설정을 관리하는 것을 config pattern이라고 한다.

이것을 쿠버네티스에서는 컨피그맵, 시크릿 같은 것이다.

컨피그맵은 db, 이미지 같은거

시크릿(암호화 기능)은 보안쪽에 치중되어 있음.

그래서 key, value 형식으로 저장되어 있음

 
































